<!doctype html><html lang="zh-CN"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width,initial-scale=1" /><meta name="generator" content="VuePress 2.0.0-rc.26" /><meta name="theme" content="VuePress Theme Plume 1.0.0-rc.173" /><script id="check-mac-os">document.documentElement.classList.toggle('mac', /Mac|iPhone|iPod|iPad/i.test(navigator.platform))</script><script id="check-dark-mode">;(function () {const um= localStorage.getItem('vuepress-theme-appearance') || 'auto';const sm = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;const isDark = um === 'dark' || (um !== 'light' && sm);document.documentElement.dataset.theme = isDark ? 'dark' : 'light';})();</script><link rel="icon" type="image/png" href="https://theme-plume.vuejs.press/favicon-32x32.png"><title>Flutter 框架沉浮录 | Halifox's Blog</title><meta name="description" content=""><link rel="preload" href="/blog/assets/style-slLKTew1.css" as="style"><link rel="stylesheet" href="/blog/assets/style-slLKTew1.css"><link rel="modulepreload" href="/blog/assets/app-82cUmJ1Q.js"><link rel="modulepreload" href="/blog/assets/index.html-D6DjZ-Kx.js"></head><body><div id="app"><!--[--><!--[--><div class="theme-plume vp-layout" vp-container data-v-85ce47ed><!--[--><!--[--><!--]--><!--[--><span tabindex="-1" data-v-766cc31c></span><a href="#VPContent" class="vp-skip-link visually-hidden" data-v-766cc31c> Skip to content </a><!--]--><!----><header class="vp-nav" data-v-85ce47ed data-v-bacec818><div class="vp-navbar" vp-navbar data-v-bacec818 data-v-2431370b><div class="wrapper" data-v-2431370b><div class="container" data-v-2431370b><div class="title" data-v-2431370b><div class="vp-navbar-title" data-v-2431370b data-v-dcaae9d0><a class="vp-link link no-icon title" href="/blog/" data-v-dcaae9d0><!--[--><!--[--><!--]--><!--[--><!--[--><!--[--><img class="vp-image dark logo" style="" src="https://theme-plume.vuejs.press/plume.png" alt data-v-38dff249><!--]--><!--[--><img class="vp-image light logo" style="" src="https://theme-plume.vuejs.press/plume.png" alt data-v-38dff249><!--]--><!--]--><!--]--><span data-v-dcaae9d0>Halifox&#39;s Blog</span><!--[--><!--]--><!--]--><!----></a></div></div><div class="content" data-v-2431370b><div class="content-body" data-v-2431370b><!--[--><!--]--><div class="vp-navbar-search search" data-v-2431370b><div class="search-wrapper" data-v-bffbf11d><!----><div id="local-search" data-v-bffbf11d><button type="button" class="mini-search mini-search-button" aria-label="搜索文档" data-v-bffbf11d><span class="mini-search-button-container"><span class="mini-search-search-icon vpi-mini-search" aria-label="search icon"></span><span class="mini-search-button-placeholder">搜索文档</span></span><span class="mini-search-button-keys"><kbd class="mini-search-button-key"></kbd><kbd class="mini-search-button-key">K</kbd></span></button></div></div></div><!--[--><!--]--><nav aria-labelledby="main-nav-aria-label" class="vp-navbar-menu menu" data-v-2431370b data-v-197b40a7><span id="main-nav-aria-label" class="visually-hidden" data-v-197b40a7>Main Navigation</span><!--[--><!--[--><a class="vp-link link navbar-menu-link" href="/blog/" tabindex="0" data-v-197b40a7 data-v-5b041338><!--[--><!----><span data-v-5b041338>首页</span><!----><!--]--><!----></a><!--]--><!--[--><a class="vp-link link navbar-menu-link" href="/blog/blog/" tabindex="0" data-v-197b40a7 data-v-5b041338><!--[--><!----><span data-v-5b041338>博客</span><!----><!--]--><!----></a><!--]--><!--]--></nav><!--[--><!--]--><!----><div class="vp-navbar-appearance appearance" data-v-2431370b data-v-92d4cecc><button class="vp-switch vp-switch-appearance" type="button" role="switch" title aria-checked="false" data-v-92d4cecc data-v-90ec5399 data-v-c4bf53b8><span class="check" data-v-c4bf53b8><span class="icon" data-v-c4bf53b8><!--[--><span class="vpi-sun sun" data-v-90ec5399></span><span class="vpi-moon moon" data-v-90ec5399></span><!--]--></span></span></button></div><div class="vp-social-links vp-navbar-social-links social-links" data-v-2431370b data-v-b22bcc59 data-v-e4d9e7c7><!--[--><!--]--></div><div class="vp-flyout vp-navbar-extra extra" data-v-2431370b data-v-8f803153 data-v-e1a10abf><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-e1a10abf><span class="vpi-more-horizontal icon" data-v-e1a10abf></span></button><div class="menu" data-v-e1a10abf><div class="vp-menu" data-v-e1a10abf data-v-9bcb6060><!----><!--[--><!--[--><!----><div class="group" data-v-8f803153><div class="item appearance" data-v-8f803153><p class="label" data-v-8f803153>外观</p><div class="appearance-action" data-v-8f803153><button class="vp-switch vp-switch-appearance" type="button" role="switch" title aria-checked="false" data-v-8f803153 data-v-90ec5399 data-v-c4bf53b8><span class="check" data-v-c4bf53b8><span class="icon" data-v-c4bf53b8><!--[--><span class="vpi-sun sun" data-v-90ec5399></span><span class="vpi-moon moon" data-v-90ec5399></span><!--]--></span></span></button></div></div></div><div class="group" data-v-8f803153><div class="item social-links" data-v-8f803153><div class="vp-social-links social-links-list" data-v-8f803153 data-v-e4d9e7c7><!--[--><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="vp-navbar-hamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="nav-screen" data-v-2431370b data-v-b76b8215><span class="container" data-v-b76b8215><span class="top" data-v-b76b8215></span><span class="middle" data-v-b76b8215></span><span class="bottom" data-v-b76b8215></span></span></button></div></div></div></div><div class="divider" data-v-2431370b><div class="divider-line" data-v-2431370b></div></div></div><!----></header><div class="vp-local-nav fixed reached-top is-posts" data-v-85ce47ed data-v-c3d9d457><button class="hidden menu" disabled aria-expanded="false" aria-controls="SidebarNav" data-v-c3d9d457><span class="vpi-align-left menu-icon" data-v-c3d9d457></span><span class="menu-text" data-v-c3d9d457>Menu</span></button><div class="vp-local-nav-outline-dropdown" style="--vp-vh:0px;" data-v-c3d9d457 data-v-ae601d4d><button data-v-ae601d4d>返回顶部</button><!----></div></div><!----><!--[--><div id="VPContent" vp-content class="vp-content" data-v-85ce47ed data-v-b3a2be45><div class="vp-doc-container is-posts" data-v-b3a2be45 data-v-40884fd8><!--[--><!--]--><div class="container" data-v-40884fd8><!----><div class="content" data-v-40884fd8><div class="content-container" data-v-40884fd8><!--[--><!--]--><main class="main" data-v-40884fd8><!----><!--[--><!--]--><!--[--><h1 class="vp-doc-title page-title" data-v-23253eb2><!----> Flutter 框架沉浮录 <!----></h1><div class="vp-doc-meta" data-v-23253eb2><!--[--><!--]--><p class="reading-time" data-v-23253eb2><span class="vpi-books icon" data-v-23253eb2></span><span data-v-23253eb2>约 4640 字</span><span data-v-23253eb2>大约 15 分钟</span></p><p data-v-23253eb2><span class="vpi-tag icon" data-v-23253eb2></span><!--[--><a class="vp-link link tag vp-tag-5imw" href="/blog/blog/tags/?tag=flutter" data-v-23253eb2><!--[-->flutter<!--]--><!----></a><!--]--></p><!--[--><!--]--><p class="create-time" data-v-23253eb2><span class="vpi-clock icon" data-v-23253eb2></span><span data-v-23253eb2>2025-12-05</span></p></div><!--]--><!--[--><!--]--><div class="_blog_1qiao7iq_ external-link-icon-enabled vp-doc plume-content" vp-content data-v-40884fd8><!--[--><!--]--><div data-v-40884fd8><h2 id="状态管理框架" tabindex="-1"><a class="header-anchor" href="#状态管理框架"><span>状态管理框架</span></a></h2><h3 id="🪦scoped-model-2017年8月17日-2022年8月24日" tabindex="-1"><a class="header-anchor" href="#🪦scoped-model-2017年8月17日-2022年8月24日"><span>🪦<a href="https://pub.dev/packages/scoped_model" target="_blank" rel="noopener noreferrer">Scoped Model</a> 2017年8月17日-2022年8月24日</span></a></h3><p>早期流行,它的理念被后来的 Provider 吸收和取代</p><h3 id="🪦redux-2016年5月17日-2021年2月23日" tabindex="-1"><a class="header-anchor" href="#🪦redux-2016年5月17日-2021年2月23日"><span>🪦<a href="https://pub.dev/packages/redux" target="_blank" rel="noopener noreferrer">Redux</a> 2016年5月17日-2021年2月23日</span></a></h3><p>从 React 社区移植，提供严格、可预测的状态管理，但因其在 Dart/Flutter 中的模板代码较多而逐渐被更简洁的方案取代。</p><h3 id="🔥bloc-cubit-2018年10月8日" tabindex="-1"><a class="header-anchor" href="#🔥bloc-cubit-2018年10月8日"><span>🔥<a href="https://pub.dev/packages/bloc" target="_blank" rel="noopener noreferrer">Bloc / Cubit</a> 2018年10月8日-</span></a></h3><p>引入了事件 (Events) -&gt; 状态 (States) 的严格分离架构，非常适合复杂的大型应用。Cubit 是 Bloc 后来推出的更轻量级版本。</p><p>优点: 逻辑与 UI 解耦最彻底；测试性极佳（因为输入输出都是纯数据）；生态系统完善（IDE 插件、日志工具）。</p><p>缺点: 样板代码较多（虽然 Cubit 简化了很多）；对于简单页面来说显得“过度设计”；新手上手门槛稍高。</p><h3 id="🔥provider-2018年10月19日" tabindex="-1"><a class="header-anchor" href="#🔥provider-2018年10月19日"><span>🔥<a href="https://pub.dev/packages/provider" target="_blank" rel="noopener noreferrer">Provider</a> 2018年10月19日-</span></a></h3><p>对 InheritedWidget/ScopedModel 的彻底简化和优化，因其简洁性和高性能迅速普及，成为 Flutter 官方推荐的方案之一。</p><p>优点: 简单易学；不仅是状态管理，更是依赖注入 (DI) 工具；与 Flutter 原生 API 贴合度高。</p><p>缺点: 严重依赖 BuildContext；不是编译时安全的（如果树中没有对应的 Provider，会抛出运行时错误 ProviderNotFoundException）；监听机制相对粗糙（Consumer 有时会写得比较繁琐）。</p><h3 id="🪦mobx-2018年12月27日-2024年12月16日" tabindex="-1"><a class="header-anchor" href="#🪦mobx-2018年12月27日-2024年12月16日"><span>🪦<a href="https://pub.dev/packages/mobx" target="_blank" rel="noopener noreferrer">MobX</a> 2018年12月27日-2024年12月16日</span></a></h3><p>从 JavaScript 生态移植，采用响应式 (Observable) 编程模型，通过代码生成简化了状态管理。</p><h3 id="🪦fish-redux-2019年3月7日-2023年12月8日" tabindex="-1"><a class="header-anchor" href="#🪦fish-redux-2019年3月7日-2023年12月8日"><span>🪦<a href="https://pub.dev/packages/fish_redux" target="_blank" rel="noopener noreferrer">Fish Redux</a> 2019年3月7日-2023年12月8日</span></a></h3><p>阿里巴巴闲鱼团队出品，基于 Redux 的组件化框架。</p><h3 id="🧊getx-不活跃-2019年11月14日-2025年2月13日" tabindex="-1"><a class="header-anchor" href="#🧊getx-不活跃-2019年11月14日-2025年2月13日"><span>🧊<a href="https://pub.dev/packages/Get" target="_blank" rel="noopener noreferrer">GetX</a> 不活跃 2019年11月14日-2025年2月13日</span></a></h3><p>以其一体化（状态、路由、依赖注入）和极简 API 迅速在全球范围内获得大量用户，尤其受到追求开发效率的开发者喜爱。</p><p>优点: 开发速度快，代码行数少；功能全面（&quot;瑞士军刀&quot;）。</p><p>缺点:</p><ul><li>Context 滥用与内存泄漏: GetX 经常宣传 &quot;不需要 Context&quot;。实际上，它通过全局变量持有了 Context/NavigatorState。这导致Controller 的生命周期与 Widget 树脱钩。如果在页面销毁后，异步任务尝试通过 GetX 操作 UI（例如显示 Dialog），可能会引用已销毁的 Context，导致崩溃或内存泄漏。</li><li>反模式 (Anti-patterns): 它是全局可变状态的集合，这让单元测试变得非常困难（因为难以隔离测试环境）；自定义的路由管理（Get.to）脱离了 Flutter 原生路由体系，导致与 Deep Linking 或其他路由库集成时出现各种 Bug。</li><li>维护风险: 作者经常在没有详细 Changelog 的情况下引入破坏性更新，且长期由单人主导，社区协作性差。</li></ul><h3 id="🔥riverpod-2020年6月23日" tabindex="-1"><a class="header-anchor" href="#🔥riverpod-2020年6月23日"><span>🔥<a href="https://pub.dev/packages/riverpod" target="_blank" rel="noopener noreferrer">Riverpod</a> 2020年6月23日-</span></a></h3><p>Provider 的彻底重构。它解决了 Provider 在编译时安全性和测试方面的痛点，并消除了对 BuildContext 的依赖，被许多人认为是下一代状态管理的首选。</p><p>优点: 编译时安全（不会出现 ProviderNotFoundException）；不依赖 BuildContext（可以在纯 Dart 逻辑中使用）；对异步数据（AsyncValue）的处理极其优雅；自动处理状态销毁和缓存。</p><h3 id="🔥signals-2023年11月27日" tabindex="-1"><a class="header-anchor" href="#🔥signals-2023年11月27日"><span>🔥<a href="https://pub.dev/packages/signals" target="_blank" rel="noopener noreferrer">Signals</a> 2023年11月27日-</span></a></h3><p>Signals 是 Flutter/Dart 状态管理领域一个相对较新的、极具影响力的概念，它借鉴了 SolidJS 和 Preact Signals 等响应式框架的设计理念。 它的目标是提供一种极简、高性能的状态管理方式，实现精细化响应式 (Fine-Grained Reactivity)。</p><p>底层实现: 基于 DAG (有向无环图) 追踪依赖关系。当一个 Signal 变化时，只有依赖它的计算属性或 Effect 会重新运行。在 Flutter 中，通常配合 Watch Widget 使用。</p><p>优点: 性能极高（实现真正的细粒度更新，例如只更新 Text 组件中的字符串，而不重建整个组件树）；API 简单直观；自动依赖追踪（无需手动声明监听）。</p><h3 id="🔥flutter-hooks-2018年12月17日" tabindex="-1"><a class="header-anchor" href="#🔥flutter-hooks-2018年12月17日"><span>🔥<a href="https://pub.dev/packages/flutter_hooks" target="_blank" rel="noopener noreferrer">Flutter Hooks</a> 2018年12月17日-</span></a></h3><p>引入 React Hooks 概念，用于简化 StatefulWidget，<strong>解决单个 Widget 内部的本地状态和生命周期管理</strong>。</p><p>flutter_hooks 的出现，使得所有基于 StatefulWidget 模式的框架，都面临着向**“函数式/声明式”**转变的压力。</p><p>Riverpod 官方推荐使用 hooks_riverpod 包。</p><p>BLoC 社区也提供了 flutter_bloc 的 Hooks 扩展。</p><p>优点: 消灭 StatefulWidget 样板代码；逻辑复用性极强（可以将 controller 的创建、销毁逻辑封装在一个 hook 函数中）；UI 代码非常紧凑。</p><p>缺点: “黑魔法”（违背了 Flutter 显式的 Widget 构建逻辑）；严重依赖 Hook 的调用顺序（不能在条件判断中使用）；增加了团队理解成本。</p><h3 id="个人见解" tabindex="-1"><a class="header-anchor" href="#个人见解"><span>个人见解</span></a></h3><p><strong>细粒度的自动依赖追踪</strong>是未来的方向，它消除了“为了连接状态和 UI 而写的样板代码”</p><h4 id="composition-over-inheritance-组合优于继承" tabindex="-1"><a class="header-anchor" href="#composition-over-inheritance-组合优于继承"><span>&quot;Composition over Inheritance&quot; (组合优于继承)</span></a></h4><p><code>BlocBuilder</code> (组合/嵌套) 比 <code>extends ConsumerWidget</code> (继承/侵入) 更好</p><ul><li><p>低侵入性：使用 Builder 模式（如 BlocBuilder 或 Consumer），你的 Widget 依然是一个纯粹的 StatelessWidget。这意味着该 Widget 的其余部分与特定框架解耦，迁移或复用更容易。</p></li><li><p>局部性：Builder 明确地圈定了“哪里需要重绘”。你看一眼代码就知道，只有包裹在 builder 里的那几行代码会动，而不是整个 Widget 类。</p></li><li><p>显式的范围控制，而不是隐式的全局/类级别注入，这符合 Flutter 官方推荐的思维模式。</p></li></ul><h4 id="依赖追踪-自动识别-auto-detect-vs-手动声明-manual-declaration" tabindex="-1"><a class="header-anchor" href="#依赖追踪-自动识别-auto-detect-vs-手动声明-manual-declaration"><span>依赖追踪：自动识别 (Auto-detect) vs 手动声明 (Manual Declaration)</span></a></h4><p><code>Watch()</code> 自动追踪状态，远胜于 <code>BlocBuilder&lt;Bloc, State&gt;</code> 的手动泛型声明。</p><ul><li><p>BLoC/Provider 不仅要写泛型，还要写 equatable 来比较 props，或者写 listenWhen/buildWhen 来过滤。这属于“命令式”的优化。</p></li><li><p>心智负担极低。你不需要告诉框架“由于 A 变了所以更新 B”，你只需要“使用 A”，框架会自动建立依赖关系。</p></li><li><p>这种模式在前端界（React Preact Signals, SolidJS, Vue）已经赢了。</p></li></ul><h4 id="细粒度更新-vs-代码拆分成本" tabindex="-1"><a class="header-anchor" href="#细粒度更新-vs-代码拆分成本"><span>细粒度更新 vs 代码拆分成本</span></a></h4><ul><li><p>性能优化的悖论：Flutter 官方说“只重建或更新 UI 中真正发生变化的那一小部分”。但现实中，业务逻辑一变，你发现原先拆分的小 Widget 需要多传一个参数，或者原先的 BlocBuilder 需要监听一个新的 State。</p></li><li><p>重构地狱：BLoC：如果你的 UI 突然需要展示 UserBloc 和 OrderBloc 的数据，你得把原本的 BlocBuilder&lt;UserBloc...&gt; 改成 MultiBlocBuilder 或者嵌套，泛型改来改去，非常痛苦。</p></li><li><p>重构地狱：Riverpod：虽然 ref.watch 解决了组合问题，但为了性能（避免整个页面重绘），你还是得把局部 UI 拆成单独的 Widget 类（ConsumerWidget），这增加了文件数量和代码跳转难度。</p></li></ul><h2 id="数据库" tabindex="-1"><a class="header-anchor" href="#数据库"><span>数据库</span></a></h2><h3 id="🔥sqflite-2017年6月28日" tabindex="-1"><a class="header-anchor" href="#🔥sqflite-2017年6月28日"><span>🔥<a href="https://pub.dev/packages/sqflite" target="_blank" rel="noopener noreferrer">sqflite</a> 2017年6月28日-</span></a></h3><p>Flutter 社区中最常用、最流行的 SQLite 插件。它提供了类似 Android 中 SQLiteOpenHelper 的 API 接口，用于执行原始 SQL 命令。</p><p>底层实现:<br> 利用 Flutter 的 Platform Channels (平台通道) 调用 Android 和 iOS 原生的 SQLite API<br> 在 Web 和桌面端（Windows/Linux/macOS）通常需要配合 sqflite_common_ffi 使用，通过 FFI (外部函数接口) 调用 SQLite 库。</p><p>优点: 生态系统极其成熟，稳定性高；标准 SQL 语法，学习成本低；大量现成的 SQL 教程和资源可用。</p><p>缺点: 需要手写 SQL 语句，容易出现拼写错误且仅在运行时发现（非类型安全）；由于使用 Platform Channels，大量数据传输时可能存在性能瓶颈（FFI 版本稍好）；样板代码（Boilerplate）较多。</p><h3 id="🧊floor不活跃-2019年3月9日-2024年5月8日" tabindex="-1"><a class="header-anchor" href="#🧊floor不活跃-2019年3月9日-2024年5月8日"><span>🧊<a href="https://pub.dev/packages/floor" target="_blank" rel="noopener noreferrer">floor</a>不活跃 2019年3月9日-2024年5月8日</span></a></h3><p>一个健壮的对象关系映射 (ORM) 库，它基于 sqflite。 它允许您使用 Dart 对象和注解来定义数据模型和数据库操作，无需手写大量 SQL，类似于 Android 的 Room 库。</p><h3 id="🔥drift-moor-2021年10月11日" tabindex="-1"><a class="header-anchor" href="#🔥drift-moor-2021年10月11日"><span>🔥<a href="https://pub.dev/packages/drift" target="_blank" rel="noopener noreferrer">drift/moor</a> 2021年10月11日-</span></a></h3><p>另一个功能强大的 ORM 库，它也基于 sqflite。它提供类型安全的 SQL 查询和强大的代码生成功能，支持 Dart Streams 以监听数据变化。</p><h3 id="🪦hive-2019年6月18日-2022年6月30日" tabindex="-1"><a class="header-anchor" href="#🪦hive-2019年6月18日-2022年6月30日"><span>🪦<a href="https://pub.dev/packages/hive" target="_blank" rel="noopener noreferrer">hive</a> 2019年6月18日-2022年6月30日</span></a></h3><p>一个轻量级、快速的键值对和NoSQL数据库，不需要原生依赖。它非常适合存储简单对象和大量数据。易于使用，但不支持复杂的查询。</p><p>底层实现: 纯 Dart 实现的追加型（Append-only）文件系统。数据以二进制形式存储在单个文件中。</p><p>优点: 无原生依赖（纯 Dart，不增加包体积，随处运行）；API 极其简单（类似 Map）；读写速度快。</p><p>缺点: 内存占用高（默认需将整个 Box 的索引/Key 加载到 RAM 中，不适合大数据量）；查询功能非常弱。</p><h3 id="🪦isar-2020年6月5日-2023年4月25日" tabindex="-1"><a class="header-anchor" href="#🪦isar-2020年6月5日-2023年4月25日"><span>🪦<a href="https://pub.dev/packages/isar" target="_blank" rel="noopener noreferrer">isar</a> 2020年6月5日-2023年4月25日</span></a></h3><p>高性能、跨平台的 NoSQL 数据库。它被设计为现代 Flutter 应用的首选数据库，提供零拷贝序列化和强大的查询功能，速度非常快。</p><p>底层实现: 基于 C++ 编写的定制核心 (基于 MDBX)，通过 Dart FFI 直接调用。</p><p>优点: 速度极快（尤其是读取）；拥有出色的查询 API（组合查询、全文搜索）；支持 ACID 事务；API 设计非常现代且易用。</p><h3 id="🧊isar-community-不活跃-2025年8月12日" tabindex="-1"><a class="header-anchor" href="#🧊isar-community-不活跃-2025年8月12日"><span>🧊<a href="https://pub.dev/packages/isar_community" target="_blank" rel="noopener noreferrer">isar_community</a> 不活跃 2025年8月12日-</span></a></h3><p>原版的 Isar 库在一段时间内,更新和维护出现停滞,Flutter 社区中的其他开发者接手并创建及其相关的依赖包</p><p>社区尝试修复原版 Isar 在新版 Flutter/Dart 中的构建错误。目前仍不活跃，且由不同的社区成员零散维护，稳定性和长期支持存在巨大风险，生产环境慎用。</p><h3 id="🔥sembast-2014年12月17日" tabindex="-1"><a class="header-anchor" href="#🔥sembast-2014年12月17日"><span>🔥<a href="https://pub.dev/packages/sembast" target="_blank" rel="noopener noreferrer">sembast</a> 2014年12月17日-</span></a></h3><p>一个NoSQL 文档存储数据库，基于 Dart 编写，支持 Web 和原生平台。它提供灵活的查询功能。</p><p>底层实现: 纯 Dart 实现。通常将数据以 JSON 格式（或其他编码）写入文件。支持在内存中运行。</p><p>优点: 纯 Dart（无原生桥接问题）；极其灵活；支持事务；可以在任何 Dart 运行的地方运行；离线/单机应用非常可靠。</p><p>缺点: 性能不如 C++底层库（如 Isar/ObjectBox/Realm）；大数据量下加载和查询较慢（通常需要将数据加载到内存中操作）。</p><h3 id="🔥objectbox-2019年10月31日" tabindex="-1"><a class="header-anchor" href="#🔥objectbox-2019年10月31日"><span>🔥<a href="https://pub.dev/packages/ObjectBox" target="_blank" rel="noopener noreferrer">ObjectBox</a> 2019年10月31日-</span></a></h3><p>一个高性能、ACID 兼容的嵌入式 NoSQL 数据库。它声称比 SQLite 更快，并提供直观的 Dart API 来直接存储对象，无需 SQL 或 ORM 转换。</p><p>底层实现: 基于 C/C++ 编写的高性能核心，通过 Dart FFI 调用。</p><h3 id="🔥realm-2023年2月7日" tabindex="-1"><a class="header-anchor" href="#🔥realm-2023年2月7日"><span>🔥<a href="https://pub.dev/packages/Realm" target="_blank" rel="noopener noreferrer">Realm</a> 2023年2月7日-</span></a></h3><p>由 MongoDB 提供支持，是一个面向对象、移动优先的数据库。它以高性能和易用性著称，</p><p>底层实现: 基于 C++ (Realm Core)，通过 Dart FFI 调用。</p><h3 id="个人见解-1" tabindex="-1"><a class="header-anchor" href="#个人见解-1"><span>个人见解</span></a></h3><h4 id="使用-sqlite-为底层的库" tabindex="-1"><a class="header-anchor" href="#使用-sqlite-为底层的库"><span>使用 SQLite 为底层的库</span></a></h4><p>SQLite 作为最老牌、最成熟的嵌入式数据库，其底层引擎久经考验，完整支持 ACID 事务特性，是数据持久化的工业标准。其可靠性在所有主流平台（包括 Web 端的 SQL.js）上得到了验证。</p><p>SQL 语言是跨平台开发者的通用语言，iOS/Android 开发者对其高度熟悉，极大降低了学习和迁移成本。同时，SQLite 拥有丰富的第三方调试工具和数据查看器，调试和维护成本极低。</p><p>长远来看，选择基于 SQLite 的方案（如 drift 或 sqflite）是追求 <strong>架构稳健性</strong> 和 <strong>低技术锁定风险</strong> 的最佳战略选择。</p><h4 id="自研-nosql-数据库的风险评估" tabindex="-1"><a class="header-anchor" href="#自研-nosql-数据库的风险评估"><span>自研/NoSQL 数据库的风险评估</span></a></h4><p>不可否认，Isar、ObjectBox、Realm 等现代数据库提供了极其便捷的开发体验和对象模型封装（如 Isar 的 @Collection 标注）。在纯粹的开发速度和特定场景的读写性能上，它们往往表现优异。</p><p>这类自研或专用底层核心的数据库（如 Isar 的 C 核心，ObjectBox 的自研存储引擎）存在巨大的 技术锁定风险 (Vendor Lock-in Risk) 。其底层机制对于大多数开发者而言是 不透明的黑盒。</p><p>Isar 原作者停止积极维护正是这一风险的有力证明。一旦核心维护者或公司放弃，社区接管难度极高，项目将面临高风险的技术停滞或弃用。</p><p>如果项目对 长期可持续性 和 技术栈通用性 要求较高，应警惕使用这类非标准化底层数据库带来的 核心维护依赖风险 。</p><h2 id="依赖注入" tabindex="-1"><a class="header-anchor" href="#依赖注入"><span>依赖注入</span></a></h2><h3 id="🪦kiwi-2018年9月9日-2024年7月22日" tabindex="-1"><a class="header-anchor" href="#🪦kiwi-2018年9月9日-2024年7月22日"><span>🪦<a href="https://pub.dev/packages/kiwi" target="_blank" rel="noopener noreferrer">kiwi</a> 2018年9月9日-2024年7月22日</span></a></h3><h3 id="🔥get-it-2018年5月22日" tabindex="-1"><a class="header-anchor" href="#🔥get-it-2018年5月22日"><span>🔥<a href="https://pub.dev/packages/get_it" target="_blank" rel="noopener noreferrer">get_it</a> 2018年5月22日-</span></a></h3><p>get_it 是 Dart 和 Flutter 社区中一个高度流行且备受推崇的服务定位器（Service Locator）。 它致力于提供一种简单、快速、类型安全的方式来管理应用程序中的依赖项（服务、模型和业务逻辑），并实现代码解耦。</p><p>原理： get_it 扮演一个全局的中央注册表（Service Locator）。 开发者在应用程序启动时，将所有服务及其创建方法（工厂）注册到这个中央注册表中。当应用程序的任何部分需要某个服务时，它就向这个定位器请求（“定位”）所需的实例。</p><h3 id="🔥injectable-2020年1月28日" tabindex="-1"><a class="header-anchor" href="#🔥injectable-2020年1月28日"><span>🔥<a href="https://pub.dev/packages/injectable" target="_blank" rel="noopener noreferrer">injectable</a> 2020年1月28日-</span></a></h3><p>injectable 并不是一个独立的依赖注入（DI）解决方案，而是为 get_it 量身定制的“代码生成器”， 旨在将 get_it 的服务定位器（Service Locator）模式提升到基于注解和编译时检查的依赖注入容器的水平。</p><p>它极大地简化了 get_it 的手动注册流程，将大部分样板代码工作交给了机器处理。</p><h2 id="网络请求" tabindex="-1"><a class="header-anchor" href="#网络请求"><span>网络请求</span></a></h2><h3 id="🔥dart-io-httpclient" tabindex="-1"><a class="header-anchor" href="#🔥dart-io-httpclient"><span>🔥dart:io HttpClient</span></a></h3><p>Dart 语言的标准库 dart:io 中提供的 HTTP 客户端。</p><p>它是所有 Dart 应用程序（包括 Flutter）进行网络请求的最底层实现。</p><p>功能强大且灵活，但使用时需要手动处理请求头、响应流、错误处理等细节，代码量较大，一般不直接用于业务开发。</p><h3 id="🔥http-2012年11月30日" tabindex="-1"><a class="header-anchor" href="#🔥http-2012年11月30日"><span>🔥<a href="https://pub.dev/packages/http" target="_blank" rel="noopener noreferrer">http</a> 2012年11月30日-</span></a></h3><p>Google 推荐的官方 HTTP 客户端库。简单、易用、轻量，但功能相对基础，常用于简单的 GET/POST 请求。</p><p>缺乏拦截器、全局配置等高级功能，文件上传/下载支持相对不便。</p><h3 id="🔥dio-2018年4月21日" tabindex="-1"><a class="header-anchor" href="#🔥dio-2018年4月21日"><span>🔥<a href="https://pub.dev/packages/dio" target="_blank" rel="noopener noreferrer">dio</a> 2018年4月21日-</span></a></h3><p>社区中最流行、功能最强大的网络请求库。提供拦截器、全局配置、FormData、文件上传下载、取消请求等功能。</p><h3 id="🔥chopper-2018年4月7日" tabindex="-1"><a class="header-anchor" href="#🔥chopper-2018年4月7日"><span>🔥<a href="https://pub.dev/packages/chopper" target="_blank" rel="noopener noreferrer">chopper</a> 2018年4月7日-</span></a></h3><p>结合 dio 或 http，通过代码生成技术，以声明式接口（类似 Java 的 Retrofit）定义 API 接口，大幅简化 API 调用代码。</p><p>Chopper 缺乏对文件上传/下载进度的原生支持，也不具备取消请求（Cancellation Token）的便捷机制。</p><p>需要通过自定义 Converter 接口处理 JSON 数据的序列化和反序列化。 但对于新手或习惯了 retrofit 流程的开发者来说，可能需要更多的配置工作来达到类型安全的自动模型转换。</p><p>相比于 dio + retrofit 这一组合，Chopper 的用户基础和社区生态相对较小。 这意味着当你遇到一些边缘或复杂的问题时，找到相关的中文或英文资料、示例代码或社区支持可能会更困难。</p><h3 id="🔥retrofit-2019年4月7日" tabindex="-1"><a class="header-anchor" href="#🔥retrofit-2019年4月7日"><span>🔥<a href="https://pub.dev/packages/retrofit" target="_blank" rel="noopener noreferrer">retrofit</a> 2019年4月7日-</span></a></h3><p>它不仅在声明式接口定义上向 Android 的 Retrofit 看齐，更重要的是，它通过强大的代码生成， 弥补了 Chopper 在自动化数据模型转换方面的缺失，实现了请求与结果的无缝序列化/反序列化。</p><h3 id="个人见解-2" tabindex="-1"><a class="header-anchor" href="#个人见解-2"><span>个人见解</span></a></h3><p>我比较喜欢<code>retrofit</code></p><h2 id="序列化" tabindex="-1"><a class="header-anchor" href="#序列化"><span>序列化</span></a></h2><h3 id="dart-convert" tabindex="-1"><a class="header-anchor" href="#dart-convert"><span><a href="https://dart.dev/libraries/dart-convert" target="_blank" rel="noopener noreferrer">dart:convert</a></span></a></h3><p>零依赖，Dart 标准库自带，简单快速，适用于极其简单的模型。</p><p>手动编写 <code>toJson()</code> 和 <code>fromJson()</code> 属于样板代码，代码冗余、繁琐。模型一旦复杂，容易出错且难以维护。</p><h3 id="built-value" tabindex="-1"><a class="header-anchor" href="#built-value"><span><a href="https://pub.dev/packages/built_value" target="_blank" rel="noopener noreferrer">built_value</a></span></a></h3><p>提供了最严格的不可变保证，强大的集合（List/Map）支持，能够创建非常一致和可靠的数据模型。</p><p>Dart 原生的 List 和 Map 是可变的。built_value 强制要求在模型中使用 BuiltList、BuiltMap 和 BuiltSet 这些专有的不可变集合类型。</p><p>当你在 Builder 中操作集合时，你实际上操作的是一个临时的、可变的集合（例如，原生的 List），一旦调用 build() 方法， 这些临时集合就会被锁定并转换为不可变的 BuiltList，附加到新的不可变模型实例上。</p><p>built_value 会自动生成 == 运算符和 hashCode，它们会递归地比较对象的所有属性和内部集合的内容，确保只有当两个对象的内容完全相同时才被认为是相等的。</p><p>由于模型不可变，你在代码库的任何地方传递数据时，都不必担心它会在不知情的情况下被另一个函数修改（即消除副作用），这极大地提高了代码的稳定性和可预测性，特别是在复杂的状态管理系统中。</p><p>built_value 通过强制性的设计模式（Builder）和特殊的不可变类型（Built Collections），从根本上防止了数据变异，从而实现了最严格、最可靠的数据模型保证。</p><h3 id="json-serializable" tabindex="-1"><a class="header-anchor" href="#json-serializable"><span><a href="https://pub.dev/packages/json_serializable" target="_blank" rel="noopener noreferrer">json_serializable</a></span></a></h3><p>自动化生成 fromJson() / toJson() 代码，极大地减少了开发工作量，高效且类型安全。通过注解（@JsonKey）可以灵活处理字段命名、默认值、忽略字段等复杂需求。</p><p>绝大多数 Flutter/Dart 生产级应用的首选。是实现序列化最平衡和推荐的方式。</p><h3 id="freezed" tabindex="-1"><a class="header-anchor" href="#freezed"><span><a href="https://pub.dev/packages/freezed" target="_blank" rel="noopener noreferrer">freezed</a></span></a></h3><p>强制实现不可变性 (Immutability)，极大地减少了状态管理中的潜在 bug。自动生成 ==, hashCode, toString 和强大的 copyWith 方法。与 json_serializable 集成完美。</p><p>实现原理和<code>built_value</code>差不多,但是 freezed 自动生成了 copyWith 方法，这是唯一“修改”不可变对象的途径。</p><h3 id="个人见解-3" tabindex="-1"><a class="header-anchor" href="#个人见解-3"><span>个人见解</span></a></h3><p>还是希望出现和<code>kotlinx.serialization</code>一样功能强大,多格式,不依赖反射,易用的序列化库</p><h2 id="多语言" tabindex="-1"><a class="header-anchor" href="#多语言"><span>多语言</span></a></h2></div><!----><!----><!----></div></main><footer class="vp-doc-footer" data-v-40884fd8 data-v-64d3fe75><!--[--><!--]--><!----><div class="contributors" aria-label="Contributors" data-v-64d3fe75><span class="contributors-label" data-v-64d3fe75>贡献者: </span><span class="contributors-info" data-v-64d3fe75><!--[--><!--[--><span class="contributor" data-v-64d3fe75>halifox</span><!----><!--]--><!--]--></span></div><nav class="prev-next" data-v-64d3fe75><div class="pager" data-v-64d3fe75><a class="vp-link link pager-link prev" href="/blog/blog/fgphhse2/" data-v-64d3fe75><!--[--><span class="desc" data-v-64d3fe75>上一页</span><span class="title" data-v-64d3fe75><!----><span data-v-64d3fe75>Flutter 记一次内存调优</span></span><!--]--><!----></a></div><div class="pager" data-v-64d3fe75><a class="vp-link link pager-link next" href="/blog/blog/fvvysa2c/" data-v-64d3fe75><!--[--><span class="desc" data-v-64d3fe75>下一页</span><span class="title" data-v-64d3fe75><!----><span data-v-64d3fe75>Flutter 官方信息渠道汇总与内容要点</span></span><!--]--><!----></a></div></nav></footer><!----><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!--]--><button type="button" class="vp-back-to-top" aria-label="back to top" data-v-85ce47ed style="display:none;" data-v-11654e35><span class="percent" data-allow-mismatch data-v-11654e35>0%</span><span class="show icon vpi-back-to-top" data-v-11654e35></span><svg aria-hidden="true" data-v-11654e35><circle cx="50%" cy="50%" data-allow-mismatch style="stroke-dasharray:calc(0% - 12.566370614359172px) calc(314.1592653589793% - 12.566370614359172px);" data-v-11654e35></circle></svg></button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" aria-label="sign down" class="vp-sign-down" aria-hidden="true" data-v-85ce47ed style="display:none;" data-v-8eeb7921><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" data-v-8eeb7921><path d="m19 11l-7 6l-7-6" data-v-8eeb7921></path><path d="m19 5l-7 6l-7-6" opacity="0.6" data-v-8eeb7921></path></g></svg><footer class="vp-footer" vp-footer data-v-85ce47ed data-v-e06d1b55><!--[--><div class="container" data-v-e06d1b55><p class="message" data-v-e06d1b55>Powered by <a target="_blank" href="https://v2.vuepress.vuejs.org/">VuePress</a> & <a target="_blank" href="https://theme-plume.vuejs.press">vuepress-theme-plume</a></p><!----></div><!--]--></footer><!--[--><!--]--><!--]--></div><!----><!--]--><!--[--><!--]--><!--]--></div><script type="module" src="/blog/assets/app-82cUmJ1Q.js" defer></script></body></html>